---------------------------------
## How can use this application? 


- Download:

		$ git clone https://github.com/limabrena/power-allocation-UAV-NOMA-RL-2users.git

		Direct download ZIP in my git repository: limabrena/power-allocation-UAV-NOMA-RL-2users
	  
- Usage: 

	This implementation can be used as a study tool to understand the 
	behavior of the achievable rate by two users and the influence
	of the allocation of power coefficients in a UAV-NOMA system. 
	The communication model presented is a base of UAV-NOMA principles and 
	can be expanded to several other scenarios, such as massive MIMO, 
	full-duplex communication, and others.
		
	The user can modify parameters and analyze the system's behavior. 
	Based on this, new methods can be proposed to solve trajectory problems, 
	power allocation, decoding order, and others in order to 
	improve the users' rate performance.
	
	Example: when the Rician Factor `K=0`, fading is similar to Rayleigh's.

----------------
## Requirement


  The implementation requires Python 3.9+ to run.

  The following libraries are required:

 - `numpy` 
 - `matplotlib.pyplot`
 - `math`
 - `random`


---------------------------------------------
## Description of the Simulation Parameters 


 - `N_mc` (integer) : Monte Carlo Samples.
 - `N_users` (integer) : number of users (in our case, two users).
 - `M_uav`(integer) : number of UAV  (in our case, single uav).
 - `snr_dB` (array of integer, size[10:2:51]) : signal-to-noise ration in dB.
 - `path_loss_exp` (integer) : path loss exponent.
 - `P_los` (float) : total power of LOS path & scattered paths.
 - `K` (integer) : Rician Factor.
 - `target_rate_primary_user` (float) : target rate in bits/s/Hertz of primary users. 
 - `target_rate_secondary_user` (float) : target rate in bits/s/Hertz of secondary users. 
 - `radius_uav` (float) : radius in meter of fly trajectory UAV.
 - `radius_user` (float) : radius of the cell of users in meters.
 - `distance`(array of float, size(N_users)) : distance between UAV and n-th user randomly calculated for each Monte Carlo sample. 
 - `ch_coeff` (complex number) : channel coefficients for each user generated by Rician distribution. This can be generated randomly following 
    using: `ch_coeff=np.sqrt((np.random.normal(s,sigma)**2) + 1j*(np.random.normal(0,sigma)**2))`.
 - `s` (float) : Non-Centrality Parameter (mean) of Rician distribution, obtained by `s=sqrt(K/(K+1)*P_los)`.
 - `sigma` (float) : Standard deviation of Rician distribution, obtained by `sigma = P_los/sqrt(2*(K+1))`.
 - `h_n` (array of float, size(N_users)) : channel coefficients over distance effects.
 - `channelGain` (array of float, size(N_users)) : channel gain `abs(h_n)^2` sorted in descending order (primary user > secondary user).

-------------------------------
## Performance analysis metrics

- `Outage Probability:` the outage probability is estimated as the ratio between the number of outage events and 
   the total number of Monte Carlo repetitions. An outage event happens when the supported user data rates for a particular 
   instantaneous channel realization is less than the target data rate. 
   
- `Achievable Rate:` the achievable rate consists of the throughput of network users, while max-min achievable rate 
   consists of the average throughput of all network users.

--------------------------------
## Adaptive Algorithm description


Adaptive power allocation algorithm was not implemented in the present version.


--------------------------------